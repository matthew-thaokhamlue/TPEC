/** * Motion System - GSAP Animation Management * Handles scroll animations, smooth scrolling, and motion preferences */class Motion {  constructor() {    this.gsapLoaded = false;    this.scrollTriggerLoaded = false;    this.scrollSmootherLoaded = false;    this.reducedMotion = false;    this.config = {      USE_SMOOTHER: false,      scrollSmoother: {        smooth: 1,        effects: true,        smoothTouch: 0.1,        normalizeScroll: true      },      scrollTrigger: {        start: "top 80%",        end: "bottom 20%",        toggleActions: "play none none reverse"      },      effects: {        revealUp: {          y: 24,          opacity: 0,          duration: 0.6,          ease: "power2.out"        },        parallax: {          speed: 0.5,          lag: 0.1        },        counter: {          duration: 2,          ease: "power2.out"        }      }    };  }  /**   * Initialize the motion system   */  async init() {    try {      this.checkReducedMotion();      await this.loadGSAP();      if (this.gsapLoaded && !this.reducedMotion) {        await this.loadScrollTrigger();        if (this.config.USE_SMOOTHER) {          await this.loadScrollSmoother();        }        this.setupAnimations();        this.setupSmoothScrolling();        this.registerEffects();      } else {        this.enableCSSFallbacks();      }      this.setupAnchorScrolling();    } catch (error) {      console.warn('Motion system initialization failed:', error);      this.enableCSSFallbacks();    }  }  /**   * Check for reduced motion preference   */  checkReducedMotion() {    this.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;    if (this.reducedMotion) {      document.body.classList.add('reduced-motion');      console.log('Reduced motion detected - animations disabled');    }    window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e) => {      this.reducedMotion = e.matches;      if (this.reducedMotion) {        document.body.classList.add('reduced-motion');        this.disableAnimations();      } else {        document.body.classList.remove('reduced-motion');        this.enableAnimations();      }    });  }  /**   * Load GSAP core library   */  async loadGSAP() {    return new Promise((resolve) => {      if (window.gsap) {        this.gsapLoaded = true;        console.log('GSAP already loaded');        resolve();        return;      }      setTimeout(() => {        if (window.gsap) {          this.gsapLoaded = true;          console.log('GSAP loaded from HTML');          resolve();        } else {          console.warn('GSAP not available - using fallbacks');          this.handleGSAPLoadFailure();          resolve();        }      }, 100);    });  }  /**   * Handle GSAP loading failure   */  handleGSAPLoadFailure() {    document.body.classList.add('no-gsap');    const fallbackCSS = `      .no-gsap .reveal-up {        opacity: 1 !important;        transform: none !important;        animation: revealUpFallback 0.6s ease-out;      }      .no-gsap .parallax-y {        will-change: auto !important;        transform: none !important;      }      @keyframes revealUpFallback {        from {          opacity: 0;          transform: translateY(24px);        }        to {          opacity: 1;          transform: translateY(0);        }      }      .no-gsap .counter {        /* Show final values immediately */      }    `;    const style = document.createElement('style');    style.textContent = fallbackCSS;    document.head.appendChild(style);    console.log('GSAP fallback styles applied');  }  /**   * Load ScrollTrigger plugin   */  async loadScrollTrigger() {    return new Promise((resolve) => {      if (window.ScrollTrigger) {        gsap.registerPlugin(ScrollTrigger);        this.scrollTriggerLoaded = true;        console.log('ScrollTrigger already loaded');        resolve();        return;      }      setTimeout(() => {        if (window.ScrollTrigger && window.gsap) {          gsap.registerPlugin(ScrollTrigger);          this.scrollTriggerLoaded = true;          console.log('ScrollTrigger loaded from HTML');        } else {          console.warn('ScrollTrigger not available - using fallbacks');        }        resolve();      }, 200);    });  }  /**   * Load ScrollSmoother plugin (Club GreenSock feature)   */  async loadScrollSmoother() {    return new Promise((resolve, reject) => {      if (window.ScrollSmoother) {        this.scrollSmootherLoaded = true;        resolve();        return;      }      console.warn('ScrollSmoother requires Club GreenSock license. Using fallback smooth scrolling.');      reject(new Error('ScrollSmoother not available'));    });  }  /**   * Setup scroll animations   */  setupAnimations() {    if (!this.gsapLoaded || !this.scrollTriggerLoaded || this.reducedMotion) {      return;    }    const revealElements = document.querySelectorAll('.reveal-up');    revealElements.forEach(element => {      gsap.fromTo(element,         this.config.effects.revealUp,        {          y: 0,          opacity: 1,          duration: this.config.effects.revealUp.duration,          ease: this.config.effects.revealUp.ease,          scrollTrigger: {            trigger: element,            start: this.config.scrollTrigger.start,            end: this.config.scrollTrigger.end,            toggleActions: this.config.scrollTrigger.toggleActions          }        }      );    });    const parallaxElements = document.querySelectorAll('.parallax-y');    parallaxElements.forEach(element => {      gsap.to(element, {        yPercent: -50 * this.config.effects.parallax.speed,        ease: "none",        scrollTrigger: {          trigger: element,          start: "top bottom",          end: "bottom top",          scrub: this.config.effects.parallax.lag        }      });    });    const counterElements = document.querySelectorAll('.counter');    counterElements.forEach(element => {      const target = parseInt(element.textContent) || 0;      const counter = { value: 0 };      gsap.to(counter, {        value: target,        duration: this.config.effects.counter.duration,        ease: this.config.effects.counter.ease,        onUpdate: () => {          element.textContent = Math.round(counter.value);        },        scrollTrigger: {          trigger: element,          start: this.config.scrollTrigger.start,          toggleActions: "play none none none"        }      });    });  }  /**   * Setup smooth scrolling   */  setupSmoothScrolling() {    if (this.config.USE_SMOOTHER && this.scrollSmootherLoaded && !this.reducedMotion) {      ScrollSmoother.create(this.config.scrollSmoother);      console.log('ScrollSmoother enabled');    } else {      this.enableNativeSmoothScroll();    }  }  /**   * Enable native smooth scrolling fallback   */  enableNativeSmoothScroll() {    document.documentElement.style.scrollBehavior = 'smooth';    if (this.reducedMotion) {      document.documentElement.style.scrollBehavior = 'auto';    }  }  /**   * Setup anchor link smooth scrolling   */  setupAnchorScrolling() {    document.addEventListener('click', (e) => {      const link = e.target.closest('a[href^="#"]');      if (!link) return;      const href = link.getAttribute('href');      if (href === '#') return;      const target = document.querySelector(href);      if (!target) return;      e.preventDefault();      if (this.gsapLoaded && !this.reducedMotion) {        gsap.to(window, {          duration: 1,          scrollTo: {            y: target,            offsetY: 80 // Account for fixed header          },          ease: "power2.inOut"        });      } else {        const offsetTop = target.offsetTop - 80;        window.scrollTo({          top: offsetTop,          behavior: this.reducedMotion ? 'auto' : 'smooth'        });      }    });  }  /**   * Register custom GSAP effects   */  registerEffects() {    if (!this.gsapLoaded || this.reducedMotion) return;    gsap.registerEffect({      name: "revealUp",      effect: (targets, config) => {        return gsap.fromTo(targets,           { y: config.distance || 24, opacity: 0 },          {             y: 0,             opacity: 1,             duration: config.duration || 0.6,            ease: config.ease || "power2.out",            stagger: config.stagger || 0.1          }        );      },      defaults: { duration: 0.6, distance: 24, ease: "power2.out" },      extendTimeline: true    });    gsap.registerEffect({      name: "fadeIn",      effect: (targets, config) => {        return gsap.fromTo(targets,          { opacity: 0 },          {            opacity: 1,            duration: config.duration || 0.4,            ease: config.ease || "power2.out",            stagger: config.stagger || 0.1          }        );      },      defaults: { duration: 0.4, ease: "power2.out" },      extendTimeline: true    });  }  /**   * Create a ScrollTrigger animation   */  createScrollTrigger(element, options = {}) {    if (!this.gsapLoaded || !this.scrollTriggerLoaded || this.reducedMotion) {      return null;    }    const config = {      ...this.config.scrollTrigger,      ...options,      trigger: element    };    return ScrollTrigger.create(config);  }  /**   * Disable all animations   */  disableAnimations() {    if (this.gsapLoaded) {      gsap.globalTimeline.pause();      ScrollTrigger.getAll().forEach(trigger => trigger.disable());    }    document.body.classList.add('reduced-motion');  }  /**   * Enable animations   */  enableAnimations() {    if (this.gsapLoaded && !this.reducedMotion) {      gsap.globalTimeline.resume();      ScrollTrigger.getAll().forEach(trigger => trigger.enable());      document.body.classList.remove('reduced-motion');    }  }  /**   * Enable CSS fallbacks when GSAP is not available   */  enableCSSFallbacks() {    document.body.classList.add('no-gsap');    document.documentElement.style.scrollBehavior = this.reducedMotion ? 'auto' : 'smooth';    console.log('Using CSS fallbacks for animations');  }  /**   * Refresh ScrollTrigger (useful after DOM changes)   */  refresh() {    if (this.scrollTriggerLoaded) {      ScrollTrigger.refresh();    }  }  /**   * Destroy all animations and clean up   */  destroy() {    if (this.scrollTriggerLoaded) {      ScrollTrigger.getAll().forEach(trigger => trigger.kill());    }    if (this.gsapLoaded) {      gsap.globalTimeline.clear();    }  }}window.Motion = new Motion();if (document.readyState === 'loading') {  document.addEventListener('DOMContentLoaded', () => {    window.Motion.init();  });} else {  window.Motion.init();}